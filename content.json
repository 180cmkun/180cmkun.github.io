{"meta":{"title":"Hk's | blog","subtitle":"","description":"","author":"hekun","url":"http://yoursite.com","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-08-08T08:26:39.396Z","updated":"2020-08-08T08:26:39.396Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2020-09-07T01:09:07.954Z","updated":"2020-09-07T01:09:07.954Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"关 于 我 首先欢迎您的到来！我主要在这个博客上分享一些有趣的程序、干货、技巧、开发教程、心情和学习记录等等！在我从一开始学习java到现在，在不断的查资料中，我发现很多人都会把一些重要的东西记录下来，方便以后查看。在现在这个互联网时代，快速的学习过程，甚至没有时间打开笔墨，博客确实是个不错的选择。既能写一年后还能看得懂博客，又能把经验变成不可替代性可见的东西。在提高自己总结性能力的同时，也让博客成为了自己一份独特的名片。 最后引用互联网上看到的一句话：“屌丝程序员的逆袭一般分两步：让自己变得牛逼，让别人知道你牛逼。”"},{"title":"文章分类","date":"2020-08-19T03:25:23.225Z","updated":"2020-08-19T03:25:23.225Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-08-08T08:26:03.376Z","updated":"2020-08-08T08:26:03.376Z","comments":true,"path":"mylist/index.html","permalink":"http://yoursite.com/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-08-08T08:24:57.354Z","updated":"2020-08-08T08:24:57.354Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"nodejs学习","slug":"Nodejs学习","date":"2020-11-06T08:43:09.830Z","updated":"2020-11-06T08:47:49.813Z","comments":true,"path":"2020/11/06/Nodejs学习/","link":"","permalink":"http://yoursite.com/2020/11/06/Nodejs%E5%AD%A6%E4%B9%A0/","excerpt":"web服务: express, koa, hapi模板引擎: handlebars, ejs, jade前端打包: webpak, fis,任务管理: gulp单元测试: karma, mocha, jasmine包管理器: npm, cnpm, yarn守护进程: pm2","text":"web服务: express, koa, hapi模板引擎: handlebars, ejs, jade前端打包: webpak, fis,任务管理: gulp单元测试: karma, mocha, jasmine包管理器: npm, cnpm, yarn守护进程: pm2 npm1.初始化 1$ npm init 依赖安装:-S（等同于–save）表示项目打包时会将该依赖包一并打包；-D（等同于–save-dev）表示该依赖包仅在开发环境下使用，正式打包不会加到项目中。 1234567891011# 安装但不写入package.json； $ npm install xxx # 安装并写入package.json的&quot;dependencies&quot;中；$ npm install xxx –S # 安装并写入package.json的&quot;evDependencies&quot;中;$ npm install xxx –D express模块1.基于nodejs的极简web服务开发框架,可以快速创建web服务器 2.项目初始化 1$ npx express-generator --view=ejs 项目名字 3.安装依赖 1$ nmp i 4.启动项目 1$ npm start 5.目录结构 bin: 启动目录 里面包含了一个启动文件 www 默认监听端口是 3000 (不用) node_modules: 所有安装的依赖模块 都在这个文件夹里面 public: 所有的前端静态资源 html css image js routes: 放的是 路由 文件 (默认有两个)路由主要定义 url 和 资源 的映射关系 ( 一一对应关系 )主要用来接收前端发送的请求 响应数据给前端 views: 主要放置 ejs 后端模板文件 app.js: 入口文件(主文件) 总路由 (其他的路由 要由它来分配) package.json: 包描述文件 最重要的是 依赖的模板列表 dependencies","categories":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"}]},{"title":"抽取JDBCU工具类——JDBCUtils的使用","slug":"抽取JDBCU工具类——JDBCUtils的使用","date":"2020-08-08T09:24:14.233Z","updated":"2020-08-19T03:25:06.030Z","comments":true,"path":"2020/08/08/抽取JDBCU工具类——JDBCUtils的使用/","link":"","permalink":"http://yoursite.com/2020/08/08/%E6%8A%BD%E5%8F%96JDBCU%E5%B7%A5%E5%85%B7%E7%B1%BB%E2%80%94%E2%80%94JDBCUtils%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"在上一篇介绍JDBC基础使用的博文中，简单了解到JDBC的使用。但是，也看出了一定的弊端：重复代码量较大。在我们每次新建一个JDBC的类操作数据库时，都要不停的进行驱动的注册，数据库的连接，参数的输入等大量重复性的操作。所以，有没有什么方法简化这一类的操作呢？其实，将这些重复的代码进行抽取，作为一个工具类，每次使用的时候进行调用即可，这样便能够达到代码的可复用性。抽取JDBC工具类的思路： 将注册驱动进行抽取 抽取一个方法获取连接对象 需求：不必传递参数，并且保证工具类的通用性。 解决：配置文件。","text":"在上一篇介绍JDBC基础使用的博文中，简单了解到JDBC的使用。但是，也看出了一定的弊端：重复代码量较大。在我们每次新建一个JDBC的类操作数据库时，都要不停的进行驱动的注册，数据库的连接，参数的输入等大量重复性的操作。所以，有没有什么方法简化这一类的操作呢？其实，将这些重复的代码进行抽取，作为一个工具类，每次使用的时候进行调用即可，这样便能够达到代码的可复用性。抽取JDBC工具类的思路： 将注册驱动进行抽取 抽取一个方法获取连接对象 需求：不必传递参数，并且保证工具类的通用性。 解决：配置文件。 一、获取连接因为我们需要将JDBC抽取为工具类，便于使用。故采取静态方法。 1.注册驱动1234COPY&#x2F;&#x2F; 用于注册驱动，加载 public static Connection getConnection() throws Exception &#123; return DriverManager.getConnection(url, user, password); &#125; 2.关闭资源&nbsp;关闭资源COPY// 用于关闭资源 public static void close(Statement stmt, Connection conn) { if (stmt != null) { try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if (conn != null) { try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } }// 方法的重载。当需要对数据库进行查询的操作时，便需要这里的第三个参数，读取完数据后，需要关闭ResultSet占用的资源 public static void close(Statement stmt, Connection conn, ResultSet rs) { if (stmt != null) { try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if (conn != null) { try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } if (rs != null) { try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } } 3.配置文件的读取因为对配置文件的读取，只需要读取一次即可拿到这些值。故采用静态代码块。 &nbsp;配置文件的读取COPY static { //读取资源文件，获取值 try { // 1.创建Properties集合类 Properties pro = new Properties(); // 获取src路径下的文件的方法--&gt;ClassLoader(类加载器，可以将字节码文件，加载进内存，且内获取src下的资源路径） ClassLoader classLoader = JDBCUtils.class.getClassLoader(); // 以当前src为文件绝对路径，获取文件资源的src //URL统一资源标识符 URL resource = classLoader.getResource(\"jdbc.properties\"); //通过getPath获取它的字符串路径 String path = resource.getPath();// System.out.println(path); // 2.加载文件 pro.load(new FileReader(path)); // 3.获取数据、复制 url = pro.getProperty(\"url\"); user = pro.getProperty(\"user\"); password = pro.getProperty(\"password\"); driver = pro.getProperty(\"driver\"); Class.forName(driver); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } 4. 配置文件配置文件放在当前模块src目录下。文件名后缀为.properties。以下为配置文件可写的内容： 1234COPYurl&#x3D;jdbc:mysql:&#x2F;&#x2F;ip:port&#x2F;database &#x2F;&#x2F;填写数据库的url，例如本地url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;db3user&#x3D;root &#x2F;&#x2F;数据库用户password&#x3D;123456 &#x2F;&#x2F; 用户密码driver&#x3D;com.mysql.jdbc.Driver &#x2F;&#x2F;注册驱动路径 5.代码总结&nbsp;代码总结COPYimport java.io.FileReader;import java.io.IOException;import java.net.URL;import java.sql.*;import java.util.Properties;public class JDBCUtils { // 为了使Connection方法可以接受到值，故将参数提升到成员变量的位置上 // 只有静态修饰的变量，才能被静态方法所访问，才能被静态代码块所访问 private static String url; private static String user; private static String password; private static String driver; /** * 文件的读取，只需要读取一次，即可拿到这些值。使用静态代码块完成 */ static { //读取资源文件，获取值 try { // 1.创建Properties集合类 Properties pro = new Properties(); // 获取src路径下的文件的方法--&gt;ClassLoader(类加载器，可以将字节码文件，加载进内存，且内获取src下的资源路径） ClassLoader classLoader = JDBCUtils.class.getClassLoader(); // 以当前src为文件绝对路径，获取文件资源的src //URL统一资源标识符 URL resource = classLoader.getResource(\"jdbc.properties\"); //通过getPath获取它的字符串路径 String path = resource.getPath();// System.out.println(path); // 2.加载文件 pro.load(new FileReader(path)); // 3.获取数据、复制 url = pro.getProperty(\"url\"); user = pro.getProperty(\"user\"); password = pro.getProperty(\"password\"); driver = pro.getProperty(\"driver\"); Class.forName(driver); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } /** * 获取连接 * 工具类，方便使用，故采用静态方法 * * @return 连接对象 */ // 用于注册驱动，加载 public static Connection getConnection() throws Exception { return DriverManager.getConnection(url, user, password); } // 用于关闭资源 public static void close(Statement stmt, Connection conn) { if (stmt != null) { try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if (conn != null) { try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } public static void close(Statement stmt, Connection conn, ResultSet rs) { if (stmt != null) { try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if (conn != null) { try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } if (rs != null) { try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } }} 二、 JDBCUtils工具类实例使用&nbsp;JDBCUtils工具类实例使用COPYimport cn.li.util.JDBCUtils;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.Statement;public class JDBCDemo10 { public static void main(String[] args) { Connection conn = null; Statement stmt = null; ResultSet rs = null; PreparedStatement pstmt = null; try { conn = JDBCUtils.getConnection(); // 获取数据库连接对象 String sql = \"select * from user where username = ? and password = ?\"; // 采用预编译的方式，提高效率，预防SQL注入 pstmt = conn.prepareStatement(sql); // 获取sql执行对象 pstmt.setString(1, \"Tom\"); pstmt.setString(2, \"1234\"); rs = pstmt.executeQuery(); boolean next = rs.next(); System.out.println(next); // 判断此用户是否存在 } catch (Exception e) { e.printStackTrace(); }finally { JDBCUtils.close(pstmt, conn, rs); //资源的释放 } }} 从以上代码实例中，可以看出我们抽取出的JDBCUtils工具类，大大简化了代码，并且增加了代码的可复用性。当我们需要更改数据库的相关配置时，只需要更改配置文件即可，而我们的JDBCUtils工具类却不用更改。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/categories/JAVA/"},{"name":"JDBC","slug":"JAVA/JDBC","permalink":"http://yoursite.com/categories/JAVA/JDBC/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"},{"name":"JDBC","slug":"JDBC","permalink":"http://yoursite.com/tags/JDBC/"},{"name":"JDBCUitls","slug":"JDBCUitls","permalink":"http://yoursite.com/tags/JDBCUitls/"}]},{"title":"JDBC基础使用","slug":"JDBC基础使用","date":"2020-08-08T08:58:00.153Z","updated":"2020-08-19T03:25:18.747Z","comments":true,"path":"2020/08/08/JDBC基础使用/","link":"","permalink":"http://yoursite.com/2020/08/08/JDBC%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/","excerpt":"定义：JDBC:Java DataBase Connectivity,即为Java数据库连接。 JDBC是Java语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了诸如查询和更新数据库中数据的方法。即：定义的一套操作所有关系型数据库的规则，是为接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接(JDBC)编程，真正执行的代码是驱动jar包中的实现类。","text":"定义：JDBC:Java DataBase Connectivity,即为Java数据库连接。 JDBC是Java语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了诸如查询和更新数据库中数据的方法。即：定义的一套操作所有关系型数据库的规则，是为接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接(JDBC)编程，真正执行的代码是驱动jar包中的实现类。 JDBC简单使用快速入门步骤： 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar1.复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下2.右键–&gt;Add As Library 注册驱动 获取数据库连接对象 Connection 定义sql 获取执行sql语句的对象 Statement 执行sql，接受返回结果 处理结果 释放资源 12345678910111213141516171819202122232425262728import java.sql.Connection;import java.sql.DriverManager;import java.sql.Statement;public class JDBCDemo01 &#123; &#x2F;** * 更新一条数据库数据 * @param args * @throws Exception *&#x2F; public static void main(String[] args) throws Exception &#123; &#x2F;&#x2F;1.导入驱动jar包（类似于Python中的第三方库 &#x2F;&#x2F;2.注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;);&#x2F;&#x2F; &#x2F;&#x2F;3.获取数据库连接对象 jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;databases 本机 Connection conn &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;url:port&#x2F;Database&quot;, &quot;username&quot;, &quot;password&quot;); &#x2F;&#x2F;4.定义sql语句 String sql &#x3D; &quot;update account set balance &#x3D; 500 where id &#x3D; 1&quot;; &#x2F;&#x2F;5.获取执行sql的对象Statement Statement stmt &#x3D; conn.createStatement(); &#x2F;&#x2F;6.执行sql int count &#x3D; stmt.executeUpdate(sql); &#x2F;&#x2F;7.处理结果 System.out.println(count); stmt.close(); conn.close(); &#125;&#125; 因为，在数据库连接、SQL语句的执行等等过程中，可能会发生异常，报错等。但是，数据库的资源要释放，故采用异常处理的方式，关闭数据库连接。 处理异常的方式：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;&#x2F;** * 1.采用异常的方式通过JDBC连接数据库 * 2.插入一条语句 *&#x2F;public class JDBCDemo02 &#123; public static void main(String[] args) &#123; &#x2F;&#x2F; 为了使Connection方法可以接受到值，故将参数提升到成员变量的位置上 Statement stmt &#x3D; null; Connection conn &#x3D; null; &#x2F;&#x2F; 异常捕获的方式处理异常 try &#123; &#x2F;&#x2F;1.注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); &#x2F;&#x2F;2.定义SQL语句 String sql &#x3D; &quot;insert into account values(null,&#39;Lisa&#39;,2000)&quot;; &#x2F;&#x2F;3.获取连接对象 conn &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;url:port&#x2F;db3&quot;, &quot;username&quot;, &quot;password&quot;); &#x2F;&#x2F;4.获取执行sql对象 stmt &#x3D; conn.createStatement(); &#x2F;&#x2F;5.执行sql int count &#x3D; stmt.executeUpdate(sql); if (count &gt; 0) &#123; System.out.println(&quot;修改成功&quot;); &#125; else &#123; System.out.println(&quot;修改失败&quot;); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; if (stmt !&#x3D; null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn !&#x3D; null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 详解DriverManager：驱动管理对象用于注册驱动，jar包导入。 12345678通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块 static &#123; try &#123; java.sql.DriverManager.registerDriver(new Driver()); &#125; catch (SQLException E) &#123; throw new RuntimeException(&quot;Can&#39;t register driver!&quot;); &#125; &#125; 原因：文件的读取，只需要读取一次，即可拿到这些值。故使用静态代码块完成。 Connection：数据库连接对象 static Connection getConnection(String url, String user, String password) 功能： 获取执行sql的对象 Statement createStatement() PreparedStatement prepareStatement(String sql) 事务管理： 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务 提交事务：commit() 回滚事务：rollback() Statement：执行sql的对象 注意：createStatement方法会造成SQL注入的问题，后期采用PreparedStatement来执行SQL对象，并采用预编译的方式，采用参数?作为占位符,且效率更高。 ResultSet：结果集对象,封装查询结果(next,类似指针移动取值方法) boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true. getXxx(参数):获取数据. 其中Int代表列的编号，参数从1开始。 String代表列的名称（参数）。 JDBC操作数据库的一般SQL语法更新操作1String sql &#x3D; &quot;update account set balance &#x3D; 500 where id &#x3D; 1&quot;; 插入操作1String sql &#x3D; &quot;insert into account values(null,&#39;Lisa&#39;,2000)&quot;; 删除操作1String sql &#x3D; &quot;delete from account where id &#x3D; 3&quot;; 创建操作1234COPYString sql &#x3D; &quot;create table student (id int primary key not null,name varchar(20))&quot;;stmt &#x3D; conn.createStatement();int count &#x3D; stmt.executeUpdate(sql);&#x2F;&#x2F;处理结果，创建表返回的为0System.out.println(count); 查询操作123456789COPYString sql &#x3D; &quot;select * from account&quot;;stmt &#x3D; conn.createStatement();resultSet &#x3D; stmt.executeQuery(sql);while (resultSet.next()) &#123; &#x2F;&#x2F;resultSet指针下移一行，并判断当前行内容是否为空，内容不为空，进入循环体 int id &#x3D; resultSet.getInt(1);&#x2F;&#x2F; 取第一列的元素 String name &#x3D; resultSet.getString(&quot;NAME&quot;); int balance &#x3D; resultSet.getInt(3); System.out.println(id + &quot;---&quot; + name + &quot;---&quot; + balance);&#125;","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/categories/JAVA/"},{"name":"JDBC","slug":"JAVA/JDBC","permalink":"http://yoursite.com/categories/JAVA/JDBC/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"},{"name":"JDBC","slug":"JDBC","permalink":"http://yoursite.com/tags/JDBC/"}]}],"categories":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/categories/nodejs/"},{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/categories/JAVA/"},{"name":"JDBC","slug":"JAVA/JDBC","permalink":"http://yoursite.com/categories/JAVA/JDBC/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"},{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"},{"name":"JDBC","slug":"JDBC","permalink":"http://yoursite.com/tags/JDBC/"},{"name":"JDBCUitls","slug":"JDBCUitls","permalink":"http://yoursite.com/tags/JDBCUitls/"}]}