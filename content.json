{"meta":{"title":"Hk's | blog","subtitle":"","description":"","author":"hekun","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于","date":"2020-08-08T08:23:17.455Z","updated":"2020-08-08T08:23:17.455Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"下面写关于自己的内容"},{"title":"所有标签","date":"2020-08-08T08:24:57.354Z","updated":"2020-08-08T08:24:57.354Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"404 Not Found","date":"2020-08-08T08:26:39.396Z","updated":"2020-08-08T08:26:39.396Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"所有分类","date":"2020-08-08T08:24:17.205Z","updated":"2020-08-08T08:24:17.205Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-08-08T08:26:03.376Z","updated":"2020-08-08T08:26:03.376Z","comments":true,"path":"mylist/index.html","permalink":"http://yoursite.com/mylist/index.html","excerpt":"","text":""}],"posts":[{"title":"抽取JDBCU工具类——JDBCUtils的使用","slug":"抽取JDBCU工具类——JDBCUtils的使用","date":"2020-08-08T09:24:14.233Z","updated":"2020-08-08T10:20:06.182Z","comments":true,"path":"2020/08/08/抽取JDBCU工具类——JDBCUtils的使用/","link":"","permalink":"http://yoursite.com/2020/08/08/%E6%8A%BD%E5%8F%96JDBCU%E5%B7%A5%E5%85%B7%E7%B1%BB%E2%80%94%E2%80%94JDBCUtils%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"在上一篇介绍JDBC基础使用的博文中，简单了解到JDBC的使用。但是，也看出了一定的弊端：重复代码量较大。在我们每次新建一个JDBC的类操作数据库时，都要不停的进行驱动的注册，数据库的连接，参数的输入等大量重复性的操作。所以，有没有什么方法简化这一类的操作呢？其实，将这些重复的代码进行抽取，作为一个工具类，每次使用的时候进行调用即可，这样便能够达到代码的可复用性。抽取JDBC工具类的思路： 将注册驱动进行抽取 抽取一个方法获取连接对象 需求：不必传递参数，并且保证工具类的通用性。 解决：配置文件。","text":"在上一篇介绍JDBC基础使用的博文中，简单了解到JDBC的使用。但是，也看出了一定的弊端：重复代码量较大。在我们每次新建一个JDBC的类操作数据库时，都要不停的进行驱动的注册，数据库的连接，参数的输入等大量重复性的操作。所以，有没有什么方法简化这一类的操作呢？其实，将这些重复的代码进行抽取，作为一个工具类，每次使用的时候进行调用即可，这样便能够达到代码的可复用性。抽取JDBC工具类的思路： 将注册驱动进行抽取 抽取一个方法获取连接对象 需求：不必传递参数，并且保证工具类的通用性。 解决：配置文件。 一、获取连接因为我们需要将JDBC抽取为工具类，便于使用。故采取静态方法。 1.注册驱动1234COPY&#x2F;&#x2F; 用于注册驱动，加载 public static Connection getConnection() throws Exception &#123; return DriverManager.getConnection(url, user, password); &#125; 2.关闭资源&nbsp;关闭资源COPY// 用于关闭资源 public static void close(Statement stmt, Connection conn) { if (stmt != null) { try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if (conn != null) { try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } }// 方法的重载。当需要对数据库进行查询的操作时，便需要这里的第三个参数，读取完数据后，需要关闭ResultSet占用的资源 public static void close(Statement stmt, Connection conn, ResultSet rs) { if (stmt != null) { try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if (conn != null) { try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } if (rs != null) { try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } } 3.配置文件的读取因为对配置文件的读取，只需要读取一次即可拿到这些值。故采用静态代码块。 &nbsp;配置文件的读取COPY static { //读取资源文件，获取值 try { // 1.创建Properties集合类 Properties pro = new Properties(); // 获取src路径下的文件的方法--&gt;ClassLoader(类加载器，可以将字节码文件，加载进内存，且内获取src下的资源路径） ClassLoader classLoader = JDBCUtils.class.getClassLoader(); // 以当前src为文件绝对路径，获取文件资源的src //URL统一资源标识符 URL resource = classLoader.getResource(\"jdbc.properties\"); //通过getPath获取它的字符串路径 String path = resource.getPath();// System.out.println(path); // 2.加载文件 pro.load(new FileReader(path)); // 3.获取数据、复制 url = pro.getProperty(\"url\"); user = pro.getProperty(\"user\"); password = pro.getProperty(\"password\"); driver = pro.getProperty(\"driver\"); Class.forName(driver); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } 4. 配置文件配置文件放在当前模块src目录下。文件名后缀为.properties。以下为配置文件可写的内容： 1234COPYurl&#x3D;jdbc:mysql:&#x2F;&#x2F;ip:port&#x2F;database &#x2F;&#x2F;填写数据库的url，例如本地url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;db3user&#x3D;root &#x2F;&#x2F;数据库用户password&#x3D;123456 &#x2F;&#x2F; 用户密码driver&#x3D;com.mysql.jdbc.Driver &#x2F;&#x2F;注册驱动路径 5.代码总结&nbsp;代码总结COPYimport java.io.FileReader;import java.io.IOException;import java.net.URL;import java.sql.*;import java.util.Properties;public class JDBCUtils { // 为了使Connection方法可以接受到值，故将参数提升到成员变量的位置上 // 只有静态修饰的变量，才能被静态方法所访问，才能被静态代码块所访问 private static String url; private static String user; private static String password; private static String driver; /** * 文件的读取，只需要读取一次，即可拿到这些值。使用静态代码块完成 */ static { //读取资源文件，获取值 try { // 1.创建Properties集合类 Properties pro = new Properties(); // 获取src路径下的文件的方法--&gt;ClassLoader(类加载器，可以将字节码文件，加载进内存，且内获取src下的资源路径） ClassLoader classLoader = JDBCUtils.class.getClassLoader(); // 以当前src为文件绝对路径，获取文件资源的src //URL统一资源标识符 URL resource = classLoader.getResource(\"jdbc.properties\"); //通过getPath获取它的字符串路径 String path = resource.getPath();// System.out.println(path); // 2.加载文件 pro.load(new FileReader(path)); // 3.获取数据、复制 url = pro.getProperty(\"url\"); user = pro.getProperty(\"user\"); password = pro.getProperty(\"password\"); driver = pro.getProperty(\"driver\"); Class.forName(driver); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } /** * 获取连接 * 工具类，方便使用，故采用静态方法 * * @return 连接对象 */ // 用于注册驱动，加载 public static Connection getConnection() throws Exception { return DriverManager.getConnection(url, user, password); } // 用于关闭资源 public static void close(Statement stmt, Connection conn) { if (stmt != null) { try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if (conn != null) { try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } public static void close(Statement stmt, Connection conn, ResultSet rs) { if (stmt != null) { try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if (conn != null) { try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } if (rs != null) { try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } }} 二、 JDBCUtils工具类实例使用&nbsp;JDBCUtils工具类实例使用COPYimport cn.li.util.JDBCUtils;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.Statement;public class JDBCDemo10 { public static void main(String[] args) { Connection conn = null; Statement stmt = null; ResultSet rs = null; PreparedStatement pstmt = null; try { conn = JDBCUtils.getConnection(); // 获取数据库连接对象 String sql = \"select * from user where username = ? and password = ?\"; // 采用预编译的方式，提高效率，预防SQL注入 pstmt = conn.prepareStatement(sql); // 获取sql执行对象 pstmt.setString(1, \"Tom\"); pstmt.setString(2, \"1234\"); rs = pstmt.executeQuery(); boolean next = rs.next(); System.out.println(next); // 判断此用户是否存在 } catch (Exception e) { e.printStackTrace(); }finally { JDBCUtils.close(pstmt, conn, rs); //资源的释放 } }} 从以上代码实例中，可以看出我们抽取出的JDBCUtils工具类，大大简化了代码，并且增加了代码的可复用性。当我们需要更改数据库的相关配置时，只需要更改配置文件即可，而我们的JDBCUtils工具类却不用更改。","categories":[],"tags":[]},{"title":"JDBC基础使用","slug":"JDBC基础使用","date":"2020-08-08T08:58:00.153Z","updated":"2020-08-08T10:22:05.504Z","comments":true,"path":"2020/08/08/JDBC基础使用/","link":"","permalink":"http://yoursite.com/2020/08/08/JDBC%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/","excerpt":"定义：JDBC:Java DataBase Connectivity,即为Java数据库连接。 JDBC是Java语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了诸如查询和更新数据库中数据的方法。即：定义的一套操作所有关系型数据库的规则，是为接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接(JDBC)编程，真正执行的代码是驱动jar包中的实现类。","text":"定义：JDBC:Java DataBase Connectivity,即为Java数据库连接。 JDBC是Java语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了诸如查询和更新数据库中数据的方法。即：定义的一套操作所有关系型数据库的规则，是为接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接(JDBC)编程，真正执行的代码是驱动jar包中的实现类。 JDBC简单使用快速入门步骤： 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar1.复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下2.右键–&gt;Add As Library 注册驱动 获取数据库连接对象 Connection 定义sql 获取执行sql语句的对象 Statement 执行sql，接受返回结果 处理结果 释放资源 12345678910111213141516171819202122232425262728import java.sql.Connection;import java.sql.DriverManager;import java.sql.Statement;public class JDBCDemo01 &#123; &#x2F;** * 更新一条数据库数据 * @param args * @throws Exception *&#x2F; public static void main(String[] args) throws Exception &#123; &#x2F;&#x2F;1.导入驱动jar包（类似于Python中的第三方库 &#x2F;&#x2F;2.注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;);&#x2F;&#x2F; &#x2F;&#x2F;3.获取数据库连接对象 jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;databases 本机 Connection conn &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;url:port&#x2F;Database&quot;, &quot;username&quot;, &quot;password&quot;); &#x2F;&#x2F;4.定义sql语句 String sql &#x3D; &quot;update account set balance &#x3D; 500 where id &#x3D; 1&quot;; &#x2F;&#x2F;5.获取执行sql的对象Statement Statement stmt &#x3D; conn.createStatement(); &#x2F;&#x2F;6.执行sql int count &#x3D; stmt.executeUpdate(sql); &#x2F;&#x2F;7.处理结果 System.out.println(count); stmt.close(); conn.close(); &#125;&#125; 因为，在数据库连接、SQL语句的执行等等过程中，可能会发生异常，报错等。但是，数据库的资源要释放，故采用异常处理的方式，关闭数据库连接。 处理异常的方式：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;&#x2F;** * 1.采用异常的方式通过JDBC连接数据库 * 2.插入一条语句 *&#x2F;public class JDBCDemo02 &#123; public static void main(String[] args) &#123; &#x2F;&#x2F; 为了使Connection方法可以接受到值，故将参数提升到成员变量的位置上 Statement stmt &#x3D; null; Connection conn &#x3D; null; &#x2F;&#x2F; 异常捕获的方式处理异常 try &#123; &#x2F;&#x2F;1.注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); &#x2F;&#x2F;2.定义SQL语句 String sql &#x3D; &quot;insert into account values(null,&#39;Lisa&#39;,2000)&quot;; &#x2F;&#x2F;3.获取连接对象 conn &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;url:port&#x2F;db3&quot;, &quot;username&quot;, &quot;password&quot;); &#x2F;&#x2F;4.获取执行sql对象 stmt &#x3D; conn.createStatement(); &#x2F;&#x2F;5.执行sql int count &#x3D; stmt.executeUpdate(sql); if (count &gt; 0) &#123; System.out.println(&quot;修改成功&quot;); &#125; else &#123; System.out.println(&quot;修改失败&quot;); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; if (stmt !&#x3D; null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn !&#x3D; null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 详解DriverManager：驱动管理对象用于注册驱动，jar包导入。 12345678通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块 static &#123; try &#123; java.sql.DriverManager.registerDriver(new Driver()); &#125; catch (SQLException E) &#123; throw new RuntimeException(&quot;Can&#39;t register driver!&quot;); &#125; &#125; 原因：文件的读取，只需要读取一次，即可拿到这些值。故使用静态代码块完成。 Connection：数据库连接对象 static Connection getConnection(String url, String user, String password) 功能： 获取执行sql的对象 Statement createStatement() PreparedStatement prepareStatement(String sql) 事务管理： 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务 提交事务：commit() 回滚事务：rollback() Statement：执行sql的对象 注意：createStatement方法会造成SQL注入的问题，后期采用PreparedStatement来执行SQL对象，并采用预编译的方式，采用参数?作为占位符,且效率更高。 ResultSet：结果集对象,封装查询结果(next,类似指针移动取值方法) boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true. getXxx(参数):获取数据. 其中Int代表列的编号，参数从1开始。 String代表列的名称（参数）。 JDBC操作数据库的一般SQL语法更新操作1String sql &#x3D; &quot;update account set balance &#x3D; 500 where id &#x3D; 1&quot;; 插入操作1String sql &#x3D; &quot;insert into account values(null,&#39;Lisa&#39;,2000)&quot;; 删除操作1String sql &#x3D; &quot;delete from account where id &#x3D; 3&quot;; 创建操作1234COPYString sql &#x3D; &quot;create table student (id int primary key not null,name varchar(20))&quot;;stmt &#x3D; conn.createStatement();int count &#x3D; stmt.executeUpdate(sql);&#x2F;&#x2F;处理结果，创建表返回的为0System.out.println(count); 查询操作123456789COPYString sql &#x3D; &quot;select * from account&quot;;stmt &#x3D; conn.createStatement();resultSet &#x3D; stmt.executeQuery(sql);while (resultSet.next()) &#123; &#x2F;&#x2F;resultSet指针下移一行，并判断当前行内容是否为空，内容不为空，进入循环体 int id &#x3D; resultSet.getInt(1);&#x2F;&#x2F; 取第一列的元素 String name &#x3D; resultSet.getString(&quot;NAME&quot;); int balance &#x3D; resultSet.getInt(3); System.out.println(id + &quot;---&quot; + name + &quot;---&quot; + balance);&#125;","categories":[],"tags":[]},{"title":"Hexo搭建个人博客（基础篇）","slug":"hexo搭建个人博客（基础篇）","date":"2020-08-08T08:53:01.116Z","updated":"2020-08-08T10:22:00.957Z","comments":true,"path":"2020/08/08/hexo搭建个人博客（基础篇）/","link":"","permalink":"http://yoursite.com/2020/08/08/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/","excerpt":"Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装Hexo建立建立 Hexo 只需要几分钟，安装 Hexo 非常简单。但是，您首先需要安装其他一些东西。 Node.js(Node.js 版本需不低于 8.6，建议使用 Node.js 10.0 及以上版本)GitGit如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。 1$ npm install -g hexo-cli 如果没有，那就一起来看下面吧 (这里只说一下 windows 的安装，因为本人现在比较穷，买不起mac啊 テ_デ，其他相关教程大家就去搜搜很多的。) 安装Git 安装地址 一切按照默认走就行了，没什么特殊的地方，安装完成之后检查git是否安装成功（执行一下cmd命令），显示版本号即为成功！ 1git --version","text":"Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装Hexo建立建立 Hexo 只需要几分钟，安装 Hexo 非常简单。但是，您首先需要安装其他一些东西。 Node.js(Node.js 版本需不低于 8.6，建议使用 Node.js 10.0 及以上版本)GitGit如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。 1$ npm install -g hexo-cli 如果没有，那就一起来看下面吧 (这里只说一下 windows 的安装，因为本人现在比较穷，买不起mac啊 テ_デ，其他相关教程大家就去搜搜很多的。) 安装Git 安装地址 一切按照默认走就行了，没什么特殊的地方，安装完成之后检查git是否安装成功（执行一下cmd命令），显示版本号即为成功！ 1git --version 安装Node.js 安装地址 我们这里简单点，直接下载并运行安装程序就完了，还是走默认就行，安装完成之后检查 node 是否安装成功（执行一下cmd命令），显示版本号即为成功！ 1node -v 安装Hexo所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。 1$ npm install -g hexo-cli 利用Hexo初始化我们的站点跟目录(文件) 123$ hexo init &lt;文件夹&gt;$ cd &lt;文件夹&gt;$ npm install 选择你想要的盘符来建立我们的博客站点文件,我这里选择 D:\\blog ，这里的 blog 是你的文件夹名字（根据自己的喜好建一个文件夹） cd 到你的站点目录下，然后 初始化站点 $ npm install，执行成功后到你的 blog 文件夹查看是否有内容，就成功了。 利用Hexo初始化站点的根目录介绍几个个命令 ,以后经常要用到的 123hexo g: 编译,生成静态文件，也就是public文件夹的东西。hexo s: 开启本地服务(以上两步的操作可以合并成hexo s -g)。hexo clean: 顾名思义就是清除缓存的意思了啦，这招一般在你改动之后网站没有变化时候用。 接下来看看初步成果吧终端在blog文件根目录： 执行命令: hexo g 和 hexo s到此为止，你的个人博客就搭建好了。","categories":[],"tags":[]}],"categories":[],"tags":[]}